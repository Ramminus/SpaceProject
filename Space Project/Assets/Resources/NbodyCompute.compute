// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
struct PlanetData {
    double3 pos;
    double mass;
    double3 velocity;
	int index;
    bool destroyed;



};
// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWStructuredBuffer<PlanetData> dataBuffer;
int number;
int loops = 30;
float timestep;

  //PEFRL Constants;



double3 CalculateForce(PlanetData p1, PlanetData p2)
{

	double GConstant = 6.674E-11;
	double3 direction = normalize(p2.pos - p1.pos);
	double r = distance(p2.pos, p1.pos);

    double m1 = p1.mass;

    double m2 = p2.mass;

    double force = (GConstant * m1 * m2 / pow(r, 2));


   



    return force * direction;


}
double3 calculateOverallForce(int i)
{
	double3 force;
	for (int x = 0; x < number; x++)
	{
		if (x != i)
		{
            if (!dataBuffer[x].destroyed)
            {
                force += CalculateForce(dataBuffer[i], dataBuffer[x]);
            }
			

		}
	}
	return force/dataBuffer[i].mass;
}
[numthreads(128,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    if (dataBuffer[id.x].destroyed)
        return;
	loops = 30;
	
	float hStep = timestep / (float) loops;
	float3 velocity = dataBuffer[id.x].velocity;
	double pefrlX = 0.1786178958448091;
	double pefrlY = -0.2123418310626054;
	double pefrlz = -0.6626458266981849E-1;
	
	for (int i = 0; i < loops; i++)
	{
		//newWorldPos = worldPos;

		dataBuffer[id.x].pos += pefrlX * hStep * velocity;
		velocity += (1 - 2 * pefrlY) * (hStep * 0.5) * calculateOverallForce(id.x);
		dataBuffer[id.x].pos += pefrlz * hStep * velocity;
		velocity += pefrlY * hStep *   calculateOverallForce(id.x);
		dataBuffer[id.x].pos += (1 - 2 * (pefrlz + pefrlX)) * hStep * velocity;
		velocity += pefrlY * hStep *   calculateOverallForce(id.x);
		dataBuffer[id.x].pos += pefrlz * hStep * velocity;
		velocity += (1 - 2 * pefrlY) * (0.5 * hStep) *   calculateOverallForce(id.x);
		dataBuffer[id.x].pos += pefrlX * hStep * velocity;
                
		//velocityMag = velocity.magnitude / 1000;
	}
    // TODO: insert actual code here!
	dataBuffer[id.x].velocity = velocity;
		
    //Result[id.xy] = float4(id.x & id.y, (id.x & 15)/15.0, (id.y & 15)/15.0, 0.0);
}

